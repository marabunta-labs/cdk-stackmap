<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- CSP Permisiva -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://fonts.googleapis.com https://fonts.gstatic.com;">

    <!-- Dependencias -->
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jointjs/3.7.7/joint.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.6.0/backbone-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jointjs/3.7.7/joint.min.js"></script>

    <title>Stack Manager - Estabilidad Total</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #1e1e1e; font-family: 'Segoe UI', sans-serif; }
        
        #paper { width: 100%; height: 100%; cursor: grab; background-color: #1e1e1e; }
        #paper.panning { cursor: grabbing; }

        /* UI Panel */
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(30, 30, 30, 0.95); 
            border: 1px solid #454545; color: #cccccc;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            width: 260px; 
            border-radius: 8px;
            display: flex; flex-direction: column;
            font-size: 13px; z-index: 100;
            backdrop-filter: blur(10px);
        }

        #ui-header {
            padding: 15px; background: rgba(255, 255, 255, 0.03);
            border-bottom: 1px solid #454545; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            font-weight: 600; user-select: none; color: #fff;
        }
        
        .arrow { font-size: 12px; transition: transform 0.3s ease; }
        #ui.collapsed .arrow { transform: rotate(-90deg); }
        #ui.collapsed #stack-list-container { display: none; }

        #stack-list { padding: 5px; max-height: 300px; overflow-y: auto; }

        .stack-row {
            display: flex; align-items: center; gap: 10px;
            padding: 8px 10px; border-radius: 6px;
            cursor: pointer; transition: background 0.2s;
        }
        .stack-row:hover { background: rgba(255, 255, 255, 0.05); }
        
        .color-dot { width: 12px; height: 12px; border-radius: 4px; }
        
        input[type="checkbox"] { accent-color: #007acc; cursor: pointer; }

        #status-bar { 
            padding: 10px 15px; font-size: 11px; color: #aaa; 
            border-top: 1px solid #333; display: flex; justify-content: space-between;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="ui-header">
            <span>Stacks: <span id="counter-text" style="color: #4fc3f7;">0/0</span></span>
            <span class="arrow">▼</span>
        </div>
        <div id="stack-list-container">
            <div id="stack-list"></div>
            <div id="status-bar">
                <span>Motor:</span> <span style="color:#00ffaa">Estable (Sin Rebote)</span>
            </div>
        </div>
    </div>

    <div id="paper"></div>

    <script>
        $(document).ready(function() {
            // ...existing code...

            // --- 1. CONFIGURACIÓN ---
            const namespace = joint.shapes;
            const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

            const paper = new joint.dia.Paper({
                el: document.getElementById('paper'),
                model: graph,
                width: '100%', height: '100%',
                gridSize: 10, drawGrid: { color: '#333', thickness: 1 },
                background: { color: '#1e1e1e' },
                cellViewNamespace: namespace,
                interactive: (cellView) => {
                    if (cellView.model.get('hidden')) return false;
                    return cellView.model.isElement();
                },
                async: true,
                sorting: joint.dia.Paper.sorting.APPROX
            });



            // --- 2. DATOS (RAW_DATA) ---
            // graphData viene como { nodes: [...], edges: [...] }
            const GRAPH_DATA = {{graphData}};
            // Unificamos nodos y aristas en un solo array RAW_DATA
            const RAW_DATA = [
                ...GRAPH_DATA.nodes,
                ...GRAPH_DATA.edges
            ];

            const stackElements = [];


            // --- 3. UI LOGIC (RAW_DATA) ---
            // Extraer stacks y colores para la UI
            const STACK_COLORS = ['#3F8624', '#FF9900', '#3355DA', '#D13212', '#8A2BE2'];
            const stacks = RAW_DATA.filter(e => e.data.type === 'Stack');
            const resources = RAW_DATA.filter(e => e.data.type !== 'Stack' && !e.data.source && !e.data.target);
            const edges = RAW_DATA.filter(e => e.data.source && e.data.target);

            function updateCounter() {
                const total = stacks.length;
                const visible = $('.stack-checkbox:checked').length;
                $('#counter-text').text(`${visible}/${total}`);
            }

            const listEl = $('#stack-list');
            stacks.forEach((data, idx) => {
                const row = $(`
                    <div class="stack-row">
                        <input type="checkbox" class="stack-checkbox" data-id="${data.data.id}" checked>
                        <div class="color-dot" style="background:${STACK_COLORS[idx % STACK_COLORS.length]}"></div>
                        <span>${data.data.label}</span>
                    </div>
                `);
                row.on('click', function(e) {
                    if (e.target.type !== 'checkbox') {
                        const cb = $(this).find('input');
                        cb.prop('checked', !cb.prop('checked')).trigger('change');
                    }
                });
                listEl.append(row);
            });
            updateCounter();

            $('#ui-header').on('click', () => $('#ui').toggleClass('collapsed'));

            $('.stack-checkbox').on('change', function() {
                const stackId = $(this).data('id');
                const isVisible = $(this).is(':checked');
                const stack = stackElements.find(el => el.get('stackName') === stackId);
                if (stack) {
                    const display = isVisible ? 'block' : 'none';
                    stack.set('hidden', !isVisible);
                    stack.attr('./display', display);
                    // Ocultar/mostrar recursos embebidos
                    stack.getEmbeddedCells().forEach(child => {
                        child.set('hidden', !isVisible);
                        child.attr('./display', display);
                    });
                    // Ocultar/mostrar todos los enlaces conectados a stack y a sus recursos
                    const allCells = [stack, ...stack.getEmbeddedCells()];
                    allCells.forEach(cell => {
                        const links = graph.getConnectedLinks(cell);
                        links.forEach(link => {
                            if (!isVisible) {
                                link.attr('./display', 'none');
                            } else {
                                const source = graph.getCell(link.source().id);
                                const target = graph.getCell(link.target().id);
                                const sourceVisible = source && !source.get('hidden');
                                const targetVisible = target && !target.get('hidden');
                                if (sourceVisible && targetVisible) {
                                    link.attr('./display', 'block');
                                } else {
                                    link.attr('./display', 'none');
                                }
                            }
                        });
                    });
                }
                updateCounter();
            });


            // --- 4. CONSTRUCCIÓN (RAW_DATA) ---
                        // --- TOOLTIP ---
                        // Crear tooltip flotante
                        const tooltip = $('<div id="graph-tooltip"></div>').css({
                            position: 'fixed',
                            pointerEvents: 'none',
                            zIndex: 9999,
                            background: 'rgba(30,30,30,0.97)',
                            color: '#fff',
                            border: '1px solid #4fc3f7',
                            borderRadius: '6px',
                            padding: '8px 14px',
                            fontSize: '13px',
                            boxShadow: '0 4px 16px rgba(0,0,0,0.3)',
                            display: 'none',
                            maxWidth: '320px',
                            whiteSpace: 'pre-line'
                        });
                        $('body').append(tooltip);

                        function showTooltip(html, x, y) {
                            tooltip.html(html).css({ left: x + 16, top: y + 16, display: 'block' });
                        }
                        function hideTooltip() {
                            tooltip.hide();
                        }

                        // --- EVENTOS DE TOOLTIP PARA NODOS ---
                        paper.on('element:mouseenter', function(cellView, evt) {
                            const model = cellView.model;
                            // No mostrar tooltip para stacks
                            if (model.get('type') === 'stack') return;
                            let info = '';
                            // Tipo AWS real
                            if (model.attributes.data && model.attributes.data.type) {
                                info += `<b>Tipo:</b> ${model.attributes.data.type}`;
                            }
                            // ID lógico
                            if (model.attributes.data && model.attributes.data.id) {
                                info += `\n<b>ID:</b> ${model.attributes.data.id}`;
                            }
                            // Stack (nombre)
                            if (model.attributes.data && model.attributes.data.parent) {
                                info += `\n<b>Stack:</b> ${model.attributes.data.parent}`;
                            }
                            showTooltip(info, evt.clientX, evt.clientY);
                        });
                        paper.on('element:mousemove', function(cellView, evt) {
                            showTooltip(tooltip.html(), evt.clientX, evt.clientY);
                        });
                        paper.on('element:mouseleave', function() {
                            hideTooltip();
                        });

                        // --- EVENTOS DE TOOLTIP PARA ENLACES ---
                        paper.on('link:mouseenter', function(linkView, evt) {
                            const model = linkView.model;
                            let info = `<b>Conexión</b>`;
                            // Buscar los nodos fuente y destino en el grafo
                            const sourceId = model.source() && model.source().id;
                            const targetId = model.target() && model.target().id;
                            let sourceLabel = sourceId;
                            let targetLabel = targetId;
                            if (sourceId) {
                                const sourceCell = model.graph.getCell(sourceId);
                                if (sourceCell && sourceCell.attributes.data && sourceCell.attributes.data.label) {
                                    sourceLabel = sourceCell.attributes.data.label;
                                }
                            }
                            if (targetId) {
                                const targetCell = model.graph.getCell(targetId);
                                if (targetCell && targetCell.attributes.data && targetCell.attributes.data.label) {
                                    targetLabel = targetCell.attributes.data.label;
                                }
                            }
                            info += `\n<b>Origen:</b> ${sourceLabel}`;
                            info += `\n<b>Destino:</b> ${targetLabel}`;
                            if (model.attributes.data) {
                                Object.entries(model.attributes.data).forEach(([k, v]) => {
                                    info += `\n<b>${k}:</b> ${v}`;
                                });
                            }
                            showTooltip(info, evt.clientX, evt.clientY);
                        });
                        paper.on('link:mousemove', function(linkView, evt) {
                            showTooltip(tooltip.html(), evt.clientX, evt.clientY);
                        });
                        paper.on('link:mouseleave', function() {
                            hideTooltip();
                        });
            const startX = 200;
            let startY = 200;

            // Crear stacks distribuidos en cuadrícula para evitar fila vertical
            const stacksPerRow = Math.ceil(Math.sqrt(stacks.length));
            const STACK_X_SPACING = 480; // Mayor separación horizontal
            const STACK_Y_SPACING = 420; // Mayor separación vertical
            stacks.forEach((stackData, i) => {
                const col = i % stacksPerRow;
                const row = Math.floor(i / stacksPerRow);
                const x = startX + col * STACK_X_SPACING + Math.random() * 60 - 30; // más jitter
                const y = startY + row * STACK_Y_SPACING + Math.random() * 60 - 30;
                const headerH = 35;
                const width = 240;
                const height = 200;
                const color = '#252526';
                const headerColor = STACK_COLORS[i % STACK_COLORS.length];

                const stack = new joint.shapes.standard.HeaderedRectangle();
                stack.position(x, y);
                stack.resize(width, height);
                stack.attr({
                    root: { title: stackData.data.id },
                    header: { fill: headerColor, stroke: '#444', height: headerH },
                    headerText: { text: stackData.data.label, fill: '#fff', fontSize: 13, fontWeight: 'bold', fontFamily: 'Segoe UI' },
                    body: { fill: color, stroke: '#555', rx: 8, ry: 8 }
                });
                stack.set('type', 'stack');
                stack.set('stackName', stackData.data.id);
                stack.addTo(graph);
                stackElements.push(stack);

                // Recursos hijos de este stack
                const childResources = resources.filter(r => r.data.parent === stackData.data.id);
                // Distribuir recursos de forma aleatoria dentro del stack
                // Colocación en espiral para evitar apilamiento incluso con muchos nodos
                const resAreaW = width - 20;
                const resAreaH = height - 40;
                const resWidth = 90;
                const resHeight = 28;
                const cx = x + width / 2 - resWidth / 2;
                const cy = y + headerH + (resAreaH / 2) - resHeight / 2;
                const spiralStep = 18; // distancia entre vueltas
                const spiralAngleStep = Math.PI / 5; // ángulo entre nodos
                childResources.forEach((res, idx) => {
                    const resNode = new joint.shapes.standard.Rectangle();
                    // Espiral: r crece con idx, ángulo también
                    const angle = idx * spiralAngleStep;
                    const radius = spiralStep * (1 + idx / (2 * Math.PI));
                    const rx = cx + Math.cos(angle) * radius;
                    const ry = cy + Math.sin(angle) * radius;
                    resNode.position(rx, ry);
                    resNode.resize(resWidth, resHeight);
                    resNode.attr({
                        body: { fill: '#333', stroke: headerColor, strokeWidth: 1, rx: 5, ry: 5, cursor: 'pointer' },
                        label: { text: res.data.label, fill: '#ddd', fontSize: 10, fontFamily: 'Segoe UI', cursor: 'pointer', textWrap: { width: 80, ellipsis: true } }
                    });
                    // Asignar los datos AWS al nodo visual para tooltips
                    resNode.set('data', res.data);
                    stack.embed(resNode);
                    resNode.addTo(graph);
                    res._cell = resNode; // Guardar referencia para enlaces
                });
                stack.fitEmbeds({ padding: 25 });
                stack._cell = stack; // Para enlaces
            });

            // Crear enlaces
            edges.forEach(edge => {
                // Buscar nodos fuente y destino
                let sourceNode = null;
                let targetNode = null;
                // Buscar en recursos
                sourceNode = resources.find(r => r.data.id === edge.data.source)?._cell;
                targetNode = resources.find(r => r.data.id === edge.data.target)?._cell;
                // Si no está en recursos, buscar en stacks
                if (!sourceNode) sourceNode = stacks.find(s => s.data.id === edge.data.source)?._cell;
                if (!targetNode) targetNode = stacks.find(s => s.data.id === edge.data.target)?._cell;
                if (sourceNode && targetNode) {
                    const link = new joint.shapes.standard.Link();
                    link.source(sourceNode);
                    link.target(targetNode);
                    link.attr({
                        line: { stroke: '#666', strokeWidth: 1.5, targetMarker: { type: 'path', d: 'M 8 -4 0 0 8 4 z' } }
                    });
                    link.connector('rounded');
                    link.addTo(graph);
                }
            });

            // --- 5. FÍSICA SIN VIBRACIÓN ---
            

            let draggedElementId = null;
            let draggingSingleNodeStack = null;
            let dragStartPointer = null;
            let dragStartStackPos = null;

            paper.on('element:pointerdown', (ev, x, y) => {
                const model = ev.model;
                // ¿Es un recurso embebido en un stack de un solo nodo?
                const parentStack = stackElements.find(stack => stack.getEmbeddedCells().length === 1 && stack.getEmbeddedCells()[0].id === model.id);
                if (parentStack && model !== parentStack) {
                    // Iniciar drag especial: mover stack completo
                    draggingSingleNodeStack = parentStack;
                    dragStartPointer = { x, y };
                    const pos = parentStack.position();
                    dragStartStackPos = { x: pos.x, y: pos.y };
                    draggedElementId = null; // No drag normal
                } else {
                    draggedElementId = model.id;
                    draggingSingleNodeStack = null;
                }
            });

            paper.on('element:pointermove', (ev, x, y) => {
                if (draggingSingleNodeStack && dragStartPointer && dragStartStackPos) {
                    // Mover stack completo
                    const dx = x - dragStartPointer.x;
                    const dy = y - dragStartPointer.y;
                    draggingSingleNodeStack.position(dragStartStackPos.x + dx, dragStartStackPos.y + dy);
                    draggingSingleNodeStack.fitEmbeds({ padding: 25 });
                }
            });

            paper.on('element:pointerup', () => {
                draggedElementId = null;
                draggingSingleNodeStack = null;
                dragStartPointer = null;
                dragStartStackPos = null;
            });


            // --- Sistema de enfriamiento simple: solo detener si no hay movimiento ---
            function physicsLoop() {
                resolveInternalPhysics();
                resolveStackCollisions();
                requestAnimationFrame(physicsLoop);
            }

            function resolveInternalPhysics() {
                let anyMoved = false;
                
                // --- AJUSTES DE FÍSICA ---
                // Ajustados para maximizar el desenredado (Layout Planar) sin perder cohesión
                const REPULSION_DIST = 450;    //200;    // Distancia de influencia de repulsión Rango muy alto para que los nodos se perciban desde lejos
                const REPULSION_STR = 80.0;    //25.0;    // Fuerza de repulsión (ajustada para estabilidad) Fuerza de repulsión muy fuerte para abrir el grafo
                const ATTRACTION_DIST = 130;   //100;   // Longitud óptima de enlaces Enlaces más largos para dar espacio a que se crucen menos
                const ATTRACTION_STR = 0.02;   //0.05;   // Fuerza del enlace (muelle) Atracción de enlaces suave para no forzar nudos
                const CENTER_PULL = 0.035;     //0.06;      // Cohesión al centro (MÁS ALTA para seguimiento rápido) Cohesión equilibrada: sigue rápido pero permite expansión
                const COLLISION_PADDING = 30;  //30;  // Espacio mínimo garantizado entre nodos Espaciado físico
                const DAMPING = 0.5;           //0.4;           // Amortiguación fuerte (0.0 muy lento -> 1.0 sin fricción) Menor momentum para evitar orbitar (más estable)
                const STOP_THRESHOLD = 0.6;    //0.8;    // Umbral para detener vibración
                const MAX_SPEED = 15;          //12;       Permitir movimientos rápidos para desenredarse
                
                stackElements.forEach(stack => {
                    if (stack.get('hidden')) return;

                    const children = stack.getEmbeddedCells();
                    if (children.length === 0) return;

                    // Calcular centro de masa actual
                    let cx = 0, cy = 0;
                    children.forEach(c => { const pt = c.getBBox().center(); cx += pt.x; cy += pt.y; });
                    cx /= children.length; cy /= children.length;

                    let stackMoved = false;

                    // --- 1. FUERZAS SUAVES (Layout) ---
                    for (let i = 0; i < children.length; i++) {
                        const nodeA = children[i];
                        if (nodeA.id === draggedElementId) continue;
                        
                        let fx = 0, fy = 0;
                        const aCenter = nodeA.getBBox().center();

                        // A. Repulsión (Muy fuerte para desenredar)
                        for (let j = 0; j < children.length; j++) {
                            if (i === j) continue;
                            const nodeB = children[j];
                            const bCenter = nodeB.getBBox().center();
                            let dx = aCenter.x - bCenter.x;
                            let dy = aCenter.y - bCenter.y;
                            let distSq = dx*dx + dy*dy;
                            let dist = Math.sqrt(distSq) || 0.1;
                            
                            if (dist < REPULSION_DIST) {
                                // Usamos una fuerza cuadrática invertida modificada para "empujar duro" al principio
                                // pero mantener influencia lejos.
                                const factor = (1 - dist / REPULSION_DIST);
                                let force = factor * factor * REPULSION_STR;
                                fx += (dx / dist) * force;
                                fy += (dy / dist) * force;
                            }
                        }

                        // B. Atracción de Enlaces (edges)
                        const connectedLinks = graph.getConnectedLinks(nodeA);
                        connectedLinks.forEach(link => {
                            const sourceId = link.source().id;
                            const targetId = link.target().id;
                            let otherNode = null;
                            if (sourceId === nodeA.id && targetId) otherNode = graph.getCell(targetId);
                            else if (targetId === nodeA.id && sourceId) otherNode = graph.getCell(sourceId);
                            
                            if (otherNode && children.includes(otherNode)) {
                                const otherCenter = otherNode.getBBox().center();
                                let dx = otherCenter.x - aCenter.x;
                                let dy = otherCenter.y - aCenter.y;
                                let dist = Math.sqrt(dx*dx + dy*dy) || 0.1;
                                
                                if (dist > ATTRACTION_DIST) { 
                                    const force = (dist - ATTRACTION_DIST) * ATTRACTION_STR;
                                    fx += (dx / dist) * force;
                                    fy += (dy / dist) * force;
                                }
                            }
                        });

                        // C. Cohesión al Centro (Seguimiento Stack)
                        fx += (cx - aCenter.x) * CENTER_PULL;
                        fy += (cy - aCenter.y) * CENTER_PULL;

                        // Aplicar Amortiguación
                        fx *= DAMPING;
                        fy *= DAMPING;

                        // Limitar Velocidad
                        const speed = Math.sqrt(fx*fx + fy*fy);
                        if (speed > MAX_SPEED) {
                            fx = (fx / speed) * MAX_SPEED;
                            fy = (fy / speed) * MAX_SPEED;
                        }

                        // Deadzone 
                        if (Math.abs(fx) < STOP_THRESHOLD) fx = 0;
                        if (Math.abs(fy) < STOP_THRESHOLD) fy = 0;

                        if (fx !== 0 || fy !== 0) {
                            nodeA.translate(fx, fy);
                            stackMoved = true;
                        }
                    }

                    // --- 2. COLISIONES FÍSICAS (Hard Constraints) ---
                    // Esto asegura que no queden pegados visualmente
                    const pad = COLLISION_PADDING;
                    for (let i = 0; i < children.length; i++) {
                        const childA = children[i];
                        for (let j = i + 1; j < children.length; j++) {
                            const childB = children[j];
                            const bA = childA.getBBox();
                            const bB = childB.getBBox();
                            
                            // Check solapamiento con padding extra
                            if (bA.x < bB.x + bB.width + pad && 
                                bA.x + bA.width + pad > bB.x &&
                                bA.y < bB.y + bB.height + pad && 
                                bA.y + bA.height + pad > bB.y) {
                                
                                const cA = bA.center();
                                const cB = bB.center();
                                let dx = cA.x - cB.x;
                                let dy = cA.y - cB.y;
                                if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) { dx = 1; dy = 0; }

                                const penX = (bA.width/2 + bB.width/2 + pad) - Math.abs(dx);
                                const penY = (bA.height/2 + bB.height/2 + pad) - Math.abs(dy);

                                let mx = 0, my = 0;
                                if (penX < penY) mx = penX * (dx > 0 ? 1 : -1);
                                else my = penY * (dy > 0 ? 1 : -1);

                                const aDrag = childA.id === draggedElementId;
                                const bDrag = childB.id === draggedElementId;
                                
                                // Resolución rígida (separación inmediata)
                                if (aDrag) {
                                    childB.translate(-mx, -my);
                                } else if (bDrag) {
                                    childA.translate(mx, my);
                                } else {
                                    childA.translate(mx * 0.5, my * 0.5);
                                    childB.translate(-mx * 0.5, -my * 0.5);
                                }
                                stackMoved = true;
                            }
                        }
                    }

                    if (stackMoved) {
                        stack.fitEmbeds({ padding: 30 });
                        anyMoved = true;
                    }
                });
                return anyMoved;
            }

            function resolveStackCollisions() {
                const padding = 15; // Padding generoso para evitar contacto visual

                for (let i = 0; i < stackElements.length; i++) {
                    const A = stackElements[i];
                    if (A.get('hidden')) continue;

                    for (let j = i + 1; j < stackElements.length; j++) {
                        const B = stackElements[j];
                        if (B.get('hidden')) continue;

                        const bA = A.getBBox();
                        const bB = B.getBBox();

                        if (bA.x < bB.x + bB.width + padding && bA.x + bA.width + padding > bB.x &&
                            bA.y < bB.y + bB.height + padding && bA.y + bA.height + padding > bB.y) {
                            
                            const cA = bA.center();
                            const cB = bB.center();
                            let dx = cA.x - cB.x;
                            let dy = cA.y - cB.y;
                            if (dx === 0 && dy === 0) dx = 1;

                            const penX = (bA.width/2 + bB.width/2 + padding) - Math.abs(dx);
                            const penY = (bA.height/2 + bB.height/2 + padding) - Math.abs(dy);

                            let mx = 0, my = 0;
                            if (penX < penY) mx = penX * (dx > 0 ? 1 : -1);
                            else my = penY * (dy > 0 ? 1 : -1);

                            // ANTI-VIBRACIÓN STACKS
                            // Umbral alto (3px). Si el choque es menor a 3px, lo ignoramos.
                            if (Math.abs(mx) < 3.0 && Math.abs(my) < 3.0) continue;

                            const aDrag = (A.id === draggedElementId || A.getEmbeddedCells().some(c => c.id === draggedElementId));
                            const bDrag = (B.id === draggedElementId || B.getEmbeddedCells().some(c => c.id === draggedElementId));

                            // Respuesta rápida para separar inmediatamente (0.8) en lugar de gradual
                            const f = 0.8; 

                            if (aDrag) B.translate(-mx * f, -my * f);
                            else if (bDrag) A.translate(mx * f, my * f);
                            else {
                                A.translate(mx * 0.5 * f, my * 0.5 * f);
                                B.translate(-mx * 0.5 * f, -my * 0.5 * f);
                            }
                        }
                    }
                }
            }

            requestAnimationFrame(physicsLoop);


            // --- 6. CÁMARA ---
            const zoomSpeed = 0.1;
            // Permitir zoom en cualquier parte del paper (fondo, stack o nodo)
            paper.el.addEventListener('wheel', function(e) {
                // Solo si Ctrl no está presionado (para no interferir con zoom del navegador)
                if (e.ctrlKey) return;
                e.preventDefault();
                // Obtener posición relativa al paper
                const rect = paper.el.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                // Delta: dirección del scroll
                const delta = e.deltaY < 0 ? 1 : -1;
                const oldScale = paper.scale().sx;
                const newScale = oldScale + (delta * zoomSpeed);
                if (newScale < 0.2 || newScale > 4) return;
                // Calcular el punto lógico bajo el cursor antes del zoom
                const tr = paper.translate();
                const logicalX = (x - tr.tx) / oldScale;
                const logicalY = (y - tr.ty) / oldScale;
                // Aplicar el nuevo zoom
                paper.scale(newScale, newScale);
                // Calcular nueva posición de ese punto bajo el nuevo zoom
                const newScreenX = logicalX * newScale + tr.tx;
                const newScreenY = logicalY * newScale + tr.ty;
                // Ajustar translate para que el punto bajo el cursor permanezca centrado
                const dx = x - newScreenX;
                const dy = y - newScreenY;
                paper.translate(tr.tx + dx, tr.ty + dy);
            }, { passive: false });

            let panning = false, panStart = {x:0, y:0};
            paper.on('blank:pointerdown', (e) => { panning=true; panStart={x:e.clientX, y:e.clientY}; $('#paper').addClass('panning'); });
            $(document).on('mousemove', (e) => {
                if(!panning) return;
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                panStart = {x:e.clientX, y:e.clientY};
                const tr = paper.translate();
                paper.translate(tr.tx + dx, tr.ty + dy);
            });
            $(document).on('mouseup', () => { panning=false; $('#paper').removeClass('panning'); });

        });
    </script>
</body>
</html>