<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://fonts.googleapis.com https://fonts.gstatic.com;">

    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jointjs/3.7.7/joint.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.6.0/backbone-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jointjs/3.7.7/joint.min.js"></script>

    <title>Stack Manager - Estabilidad Total</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #1e1e1e; font-family: 'Segoe UI', sans-serif; }
        
        #paper { width: 100%; height: 100%; cursor: grab; background-color: #1e1e1e; }
        #paper.panning { cursor: grabbing; }

        /* UI Panel Container */
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(30, 30, 30, 0.95); 
            border: 1px solid #454545; color: #cccccc;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            width: 260px; 
            border-radius: 8px;
            display: flex; flex-direction: column;
            font-size: 13px; z-index: 100;
            backdrop-filter: blur(10px);
            padding-bottom: 10px;
            transition: max-height 0.3s;
        }
        
        #ui.collapsed .ui-section-content, 
        #ui.collapsed #center-view-btn { display: none; }

        /* Cabeceras (Stacks y Descargar) */
        .ui-section-header {
            background: #333;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
            user-select: none;
            transition: background 0.2s;
        }

        .ui-section-header:hover { background: #3a3a3a; }

        #counter-text { color: #4fc3f7; font-weight: bold; }
        .arrow { font-size: 12px; transition: transform 0.3s ease; }
        .ui-section-header.active .arrow { transform: rotate(180deg); }

        /* Contenido Desplegable (Animación) */
        .ui-section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: #222;
        }

        .ui-section-content.open {
            max-height: 300px;
            overflow-y: auto;
        }

        /* Lista de Stacks */
        #stack-list { padding: 5px; }
        .stack-row {
            display: flex; align-items: center; gap: 10px;
            padding: 8px 10px; border-radius: 6px;
            cursor: pointer; transition: background 0.2s;
        }
        .stack-row:hover { background: rgba(255, 255, 255, 0.05); }
        input[type="checkbox"] { accent-color: #007acc; cursor: pointer; }

        /* Botón Centrar Vista */
        #center-view-btn {
            display: block;
            margin: 10px auto 0 auto;
            width: 92%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: #4fc3f722;
            color: #4fc3f7;
            font-weight: 700;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        #center-view-btn:hover {
            background: #4fc3f7;
            color: #111;
        }

        /* Botones de Descarga (Estilo Lista) */
        .download-item {
            width: 100%;
            padding: 12px 15px;
            background: transparent;
            border: none;
            color: #bbb;
            text-align: left;
            cursor: pointer;
            border-bottom: 1px solid #333;
            font-size: 13px;
            transition: color 0.2s, background 0.2s;
        }
        .download-item:last-child { border-bottom: none; }
        .download-item:hover { background: #2a2a2a; color: #fff; }

        /* #download-png-btn { color: #4fc3f7; }
        #download-png-btn:hover { color: #8bf6ff; } */

    </style>
</head>
<body>

    <div id="ui">
        <div class="ui-section-header" id="stacks-header">
            <span>Stacks: <span id="counter-text">0/0</span></span>
            <span class="arrow">▼</span>
        </div>
        <div class="ui-section-content" id="stacks-content">
            <div id="stack-list"></div>
        </div>

        <div class="ui-section-header" id="filters-header">
            <span>Filtros por Tipo</span>
            <span class="arrow">▼</span>
        </div>
        <div class="ui-section-content" id="filters-content">
            <div id="filter-list" style="padding: 10px;"></div>
        </div>

        <div class="ui-section-header" id="download-header">
            <span>Descargar</span>
            <span class="arrow">▼</span>
        </div>
        <div class="ui-section-content" id="download-content">
            <div class="download-list">
                <button id="download-svg-btn" class="download-item">Descargar SVG</button>
                <button id="download-png-btn" class="download-item">Descargar PNG</button>
            </div>
        </div>

        <button id="center-view-btn">Centrar vista</button>
    </div>

    <div id="paper"></div>

    <div id="minimap" style="position:fixed;right:24px;bottom:24px;width:220px;height:140px;background:rgba(30,30,30,0.95);border:2px solid #4fc3f7;border-radius:10px;z-index:200;box-shadow:0 2px 12px #0008;pointer-events:auto;">
        <svg id="minimap-svg" width="220" height="140" style="display:block;cursor:pointer;pointer-events:auto;"></svg>
    </div>

<script>
    // =================================================================
    // 1. API GLOBAL (Crucial: Solo se llama una vez)
    // =================================================================
    const vscode = acquireVsCodeApi(); 

    // 1. Definición inicial basada en config inyectada
    const conf = window.__USER_CONFIG__ || {};
    const initialW = conf.graphAreaWidth || 10000;
    const initialH = conf.graphAreaHeight || 6000;

    // Calculamos coordenadas centradas en 0,0
    let GRAPH_AREA = { 
        minX: -initialW / 2, 
        minY: -initialH / 2, 
        maxX: initialW / 2, 
        maxY: initialH / 2 
    };

    // Definir área del grafo GLOBAL para que todos la vean
    //const GRAPH_AREA = { minX: -5000, minY: -3000, maxX: 5000, maxY: 3000 };

    function clampPosition(x, y, width, height) {
        const clampedX = Math.max(GRAPH_AREA.minX, Math.min(x, GRAPH_AREA.maxX - width));
        const clampedY = Math.max(GRAPH_AREA.minY, Math.min(y, GRAPH_AREA.maxY - height));
        return { x: clampedX, y: clampedY };
    }

    $(document).ready(function() {
        
        // =================================================================
        // 2. CONFIGURACIÓN E INICIALIZACIÓN
        // =================================================================
        
        const STACK_HEADER_HEIGHT = 40;
        const HEADER_PADDING = 10;

        // Listener de mensajes de la extensión (Configuración)
        window.addEventListener('message', (event) => {
            const message = event.data;
            if (message && message.type === 'updateConfig' && message.config) {
                if (typeof message.config.showMinimap !== 'undefined') {
                    if (message.config.showMinimap === false) {
                        $('#minimap').css('display', 'none');
                    } else {
                        $('#minimap').css('display', 'block');
                    }
                }
                // Actualizar colores si cambia el modo
                if (typeof message.config.nodeColorMode !== 'undefined' && typeof window.getResourceColor === 'function' && Array.isArray(window.resources)) {
                    window.resources.forEach((res) => {
                        if (!res._cell) return;
                        const resourceColor = window.getResourceColor(res.data.type);
                        if (message.config.nodeColorMode === 'border') {
                            res._cell.attr('body/fill', '#222');
                            res._cell.attr('body/stroke', resourceColor);
                            res._cell.attr('body/strokeWidth', 3);
                        } else {
                            res._cell.attr('body/fill', resourceColor);
                            res._cell.attr('body/stroke', '#222');
                            res._cell.attr('body/strokeWidth', 1);
                        }
                    });
                }
                if (typeof message.config.graphAreaWidth === 'number' || typeof message.config.graphAreaHeight === 'number') {
                    const w = message.config.graphAreaWidth || (GRAPH_AREA.maxX - GRAPH_AREA.minX);
                    const h = message.config.graphAreaHeight || (GRAPH_AREA.maxY - GRAPH_AREA.minY);
                    
                    GRAPH_AREA = {
                        minX: -w / 2, 
                        minY: -h / 2, 
                        maxX: w / 2, 
                        maxY: h / 2 
                    };

                    // IMPORTANTE: Actualizar el borde visual (rectángulo azul)
                    // Asumiendo que guardaste la referencia a 'areaBorder' en una variable global o accesible
                    if (typeof areaBorder !== 'undefined') {
                        areaBorder.position(GRAPH_AREA.minX, GRAPH_AREA.minY);
                        areaBorder.resize(w, h);
                    }
                }
                window.__USER_CONFIG__ = Object.assign({}, window.__USER_CONFIG__, message.config);
            }
        });

        // Visibilidad inicial del minimapa
        if (window.__USER_CONFIG__ && window.__USER_CONFIG__.showMinimap === false) {
            $('#minimap').css('display', 'none');
        } else {
            $('#minimap').css('display', 'block');
        }

        // Inicializar Graph y Paper
        const namespace = joint.shapes;
        const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

        const paper = new joint.dia.Paper({
            el: document.getElementById('paper'),
            model: graph,
            width: '100%', height: '100%',
            gridSize: 10, drawGrid: { color: '#333', thickness: 1 },
            background: { color: '#1e1e1e' },
            cellViewNamespace: namespace,
            interactive: (cellView) => {
                if (cellView.model.get('hidden')) return false;
                return cellView.model.isElement();
            },
            async: true,
            sorting: joint.dia.Paper.sorting.APPROX
        });

        // =================================================================
        // 3. PROCESAMIENTO DE DATOS Y CONSTRUCCIÓN
        // =================================================================
        
        const GRAPH_DATA = {{graphData}};
        const RAW_DATA = [...GRAPH_DATA.nodes, ...GRAPH_DATA.edges];
        const stackElements = [];
        
        let STACK_COLORS = ['#3F8624', '#FF9900', '#3355DA', '#D13212', '#8A2BE2'];
        const stacks = RAW_DATA.filter(e => e.data.type === 'Stack');
        const resources = RAW_DATA.filter(e => e.data.type !== 'Stack' && !e.data.source && !e.data.target);
        window.resources = resources; 
        const edges = RAW_DATA.filter(e => e.data.source && e.data.target);

        // --- CONSTRUCCIÓN UI LISTA DE STACKS ---
        function updateCounter() {
            const total = stacks.length;
            const visible = $('.stack-checkbox:checked').length;
            $('#counter-text').text(`${visible}/${total}`);
        }

        const listEl = $('#stack-list');
        stacks.forEach((data, idx) => {
            const color = STACK_COLORS[idx % STACK_COLORS.length];
            const row = $(
                `<div class="stack-row" style="justify-content:space-between;">
                <div style="display:flex;align-items:center;gap:8px;">
                    <input type="checkbox" class="stack-checkbox" data-id="${data.data.id}" checked>
                    <span>${data.data.label}</span>
                </div>
                <input type="color" class="stack-color-picker" data-idx="${idx}" value="${color}" style="width:22px;height:22px;border:none;background:none;cursor:pointer;">
            </div>
        `);
            row.on('click', function (e) {
                if (e.target.type !== 'checkbox' && e.target.type !== 'color') {
                    const cb = $(this).find('input[type="checkbox"]');
                    cb.prop('checked', !cb.prop('checked')).trigger('change');
                }
            });
            listEl.append(row);
        });

        $('.stack-color-picker').on('input', function (e) {
            const idx = parseInt($(this).data('idx'));
            const newColor = $(this).val();
            STACK_COLORS[idx] = newColor;
            const stack = stackElements[idx];
            if (stack) {
                stack.attr('header/fill', newColor);
            }
        });
        updateCounter();

        // --- LOGICA ACORDEON ---
        $('.ui-section-header').on('click', function() {
            $(this).toggleClass('active');
            $(this).next('.ui-section-content').toggleClass('open');
        });

        // Visibilidad de Stacks
        $('.stack-checkbox').on('change', function () {
            const stackId = $(this).data('id');
            const isVisible = $(this).is(':checked');
            const stack = stackElements.find(el => el.get('stackName') === stackId);
            if (stack) {
                const display = isVisible ? 'block' : 'none';
                stack.set('hidden', !isVisible);
                stack.attr('./display', display);
                stack.getEmbeddedCells().forEach(child => {
                    child.set('hidden', !isVisible);
                    child.attr('./display', display);
                });
                // Actualizar enlaces
                const allCells = [stack, ...stack.getEmbeddedCells()];
                allCells.forEach(cell => {
                    const links = graph.getConnectedLinks(cell);
                    links.forEach(link => {
                        if (!isVisible) {
                            link.attr('./display', 'none');
                        } else {
                            const source = graph.getCell(link.source().id);
                            const target = graph.getCell(link.target().id);
                            const sourceVisible = source && !source.get('hidden');
                            const targetVisible = target && !target.get('hidden');
                            if (sourceVisible && targetVisible) link.attr('./display', 'block');
                            else link.attr('./display', 'none');
                        }
                    });
                });
            }
            updateCounter();
        });

        // --- TOOLTIP MEJORADO ---
        const tooltip = $('<div id="graph-tooltip"></div>').css({
            position: 'fixed', pointerEvents: 'none', zIndex: 9999,
            background: 'rgba(30,30,30,0.97)', color: '#fff',
            border: '1px solid #4fc3f7', borderRadius: '6px',
            padding: '8px 14px', fontSize: '13px',
            boxShadow: '0 4px 16px rgba(0,0,0,0.3)', display: 'none',
            maxWidth: '320px', whiteSpace: 'pre-line'
        });
        $('body').append(tooltip);

        function showTooltip(html, x, y) { tooltip.html(html).css({ left: x + 16, top: y + 16, display: 'block' }); }
        function hideTooltip() { tooltip.hide(); }

        // Función auxiliar para limpiar nombres (ID y Stacks)
        function cleanName(text) {
            if (!text) return '';
            return text
                .replace(/_\d+$/, '')           // Quita sufijos numéricos (ej: _308, _179)
                .replace(/[A-Fa-f0-9]{8}$/, '') // Quita hashes de 8 chars (ej: C8295D)
                .replace(/_[A-Za-z0-9]+$/, ''); // Quita sufijos mixtos con guion bajo
        }

        paper.on('element:mouseenter', function (cellView, evt) {
            const model = cellView.model;
            // Ignoramos el tooltip para la caja contenedora del Stack
            if (model.get('type') === 'stack') return;

            let info = '';
            
            // 1. Tipo de Recurso
            if (model.attributes.data && model.attributes.data.type) {
                // Quitamos el prefijo 'AWS::' para que sea más limpio
                const shortType = model.attributes.data.type.replace(/^AWS::\w+::/, '');
                info += `<b>Tipo:</b> ${shortType}`;
            }

            // 2. ID (Limpiamos el nombre aquí)
            if (model.attributes.data && model.attributes.data.id) {
                const cleanId = cleanName(model.attributes.data.id);
                info += `\n<b>ID:</b> ${cleanId}`;
            }

            // 3. Stack Padre (Limpiamos el nombre aquí también)
            if (model.attributes.data && model.attributes.data.parent) {
                const cleanParent = cleanName(model.attributes.data.parent);
                info += `\n<b>Stack:</b> ${cleanParent}`;
            }

            showTooltip(info, evt.clientX, evt.clientY);
        });

        paper.on('element:mousemove', (cellView, evt) => showTooltip(tooltip.html(), evt.clientX, evt.clientY));
        paper.on('element:mouseleave', hideTooltip);

        // También aplicamos la limpieza a los ENLACES (flechas)
        paper.on('link:mouseenter', function (linkView, evt) {
            const model = linkView.model;
            let info = `<b>Conexión</b>`;
            
            const sourceId = model.source() && model.source().id;
            const targetId = model.target() && model.target().id;
            
            let sourceLabel = '?', targetLabel = '?';

            // Buscar etiquetas reales y limpiarlas
            if (sourceId) { 
                const s = model.graph.getCell(sourceId); 
                if(s && s.attributes.data) sourceLabel = cleanName(s.attributes.data.label || s.attributes.data.id); 
            }
            if (targetId) { 
                const t = model.graph.getCell(targetId); 
                if(t && t.attributes.data) targetLabel = cleanName(t.attributes.data.label || t.attributes.data.id); 
            }

            info += `\n<b>Origen:</b> ${sourceLabel}\n<b>Destino:</b> ${targetLabel}`;
            showTooltip(info, evt.clientX, evt.clientY);
        });
        paper.on('link:mousemove', (linkView, evt) => showTooltip(tooltip.html(), evt.clientX, evt.clientY));
        paper.on('link:mouseleave', hideTooltip);


        // =========================================================
        // DEFINICIÓN DE CATEGORÍAS (Para Colores y Filtros)
        // =========================================================
        const RESOURCE_CATEGORIES = {
            'Compute': {
                color: '#FF9900',
                types: ['Function', 'Instance', 'AutoScalingGroup', 'LaunchConfiguration', 'ECSCluster', 'TaskDefinition', 'Service', 'StateMachine', 'BatchJobDefinition', 'BatchJobQueue']
            },
            'Storage': {
                color: '#3F8624',
                types: ['Bucket', 'FileSystem', 'Volume', 'BackupVault', 'StorageLens']
            },
            'Database': {
                color: '#3355DA',
                types: ['Table', 'DBInstance', 'DBCluster', 'DBSubnetGroup', 'GlobalTable', 'ReplicationGroup', 'CacheCluster']
            },
            'Networking': {
                color: '#8A2BE2',
                types: ['VPC', 'Subnet', 'RouteTable', 'InternetGateway', 'NatGateway', 'SecurityGroup', 'NetworkAcl', 'VPCEndpoint', 'LoadBalancer', 'Listener']
            },
            'Security': {
                color: '#D13212',
                types: ['Role', 'User', 'Group', 'Policy', 'ManagedPolicy', 'AccessKey', 'Secret', 'Key']
            },
            'Management': {
                color: '#E03088',
                types: ['Stack', 'Parameter', 'Alarm', 'Dashboard', 'LogGroup', 'LogStream', 'EventRule', 'Trail', 'ConfigRule']
            },
            'Integration': {
                color: '#D9A741',
                types: ['Queue', 'Topic', 'Subscription', 'EventBus', 'Api', 'Connection', 'Integration']
            },
            'Analytics': {
                color: '#9C27B0',
                types: ['Stream', 'DeliveryStream', 'Dataset', 'Crawler', 'Job', 'WorkGroup']
            },
            'Otros': {
                color: '#666666',
                types: [] // Aquí caerá todo lo demás
            }
        };

        function buildFilterUI() {
            const container = $('#filter-list');
            container.empty();

            // 1. Identificar qué tipos existen en el grafo actual
            const existingTypes = new Set();
            window.resources.forEach(res => {
                const t = res.data.type.replace(/^AWS::[\w]+::/, '');
                existingTypes.add(t);
            });

            // 2. Agrupar por Categoría
            const groups = {};
            existingTypes.forEach(type => {
                let foundCat = 'Otros';
                for (const [catName, catData] of Object.entries(RESOURCE_CATEGORIES)) {
                    if (catData.types.includes(type)) {
                        foundCat = catName;
                        break;
                    }
                }
                if (!groups[foundCat]) groups[foundCat] = [];
                groups[foundCat].push(type);
            });

            // 3. Renderizar HTML (Acordeones anidados o Títulos simples)
            // Usaremos títulos pequeños para separar categorías
            Object.keys(groups).forEach(catName => {
                const types = groups[catName];
                if (types.length === 0) return;

                // Título de Categoría
                const catHeader = $(`<div style="font-weight:bold; color:${RESOURCE_CATEGORIES[catName].color}; margin-top:8px; margin-bottom:4px; font-size:11px; text-transform:uppercase;">${catName}</div>`);
                container.append(catHeader);

                // Checkboxes para cada tipo
                types.forEach(type => {
                    const row = $(`
                        <div class="filter-row" style="display:flex; align-items:center; gap:8px; margin-bottom:4px; padding-left:8px;">
                            <input type="checkbox" class="type-filter-cb" data-type="${type}" checked>
                            <span style="font-size:12px; color:#bbb;">${type}</span>
                        </div>
                    `);
                    container.append(row);
                });
            });

            // 4. Lógica de Filtrado
            $('.type-filter-cb').on('change', function() {
                const typeToToggle = $(this).data('type');
                const isVisible = $(this).is(':checked');

                // Filtrar recursos
                window.resources.forEach(res => {
                    const t = res.data.type.replace(/^AWS::[\w]+::/, '');
                    if (t === typeToToggle && res._cell) {
                        
                        // Ocultar/Mostrar celda
                        const display = isVisible ? 'block' : 'none';
                        res._cell.attr('./display', display);
                        res._cell.set('hidden', !isVisible);

                        // Actualizar enlaces conectados
                        const links = graph.getConnectedLinks(res._cell);
                        links.forEach(link => {
                            if (!isVisible) {
                                link.attr('./display', 'none');
                            } else {
                                // Solo mostramos el link si AMBOS extremos son visibles
                                const sId = link.source().id;
                                const tId = link.target().id;
                                const sCell = graph.getCell(sId);
                                const tCell = graph.getCell(tId);
                                
                                // Chequeo de seguridad por si es un stack lo que está al otro lado
                                const sHidden = sCell.get('hidden');
                                const tHidden = tCell.get('hidden');

                                if (!sHidden && !tHidden) {
                                    link.attr('./display', 'block');
                                }
                            }
                        });
                    }
                });
                stackElements.forEach(stack => {
                    updateStackLayout(stack);
                });
            });
        }

        // LLAMAR A LA FUNCIÓN AL INICIAR
        buildFilterUI();

        // --- CONSTRUCCIÓN DEL GRAFO ---
        const areaCenterX = (GRAPH_AREA.minX + GRAPH_AREA.maxX) / 2;
        const areaCenterY = (GRAPH_AREA.minY + GRAPH_AREA.maxY) / 2;
        const stacksPerRow = Math.ceil(Math.sqrt(stacks.length));
        const STACK_X_SPACING = 800;
        const STACK_Y_SPACING = 200;
        const gridWidth = stacksPerRow * STACK_X_SPACING;
        const gridHeight = Math.ceil(stacks.length / stacksPerRow) * STACK_Y_SPACING;
        const startX = areaCenterX - gridWidth / 2;
        let startY = areaCenterY - gridHeight / 2;


        // Nueva función getResourceColor optimizada
        function getResourceColor(fullType) {
            if (!fullType) return '#333';
            const shortType = fullType.replace(/^AWS::[\w]+::/, '');
            
            for (const [catName, catData] of Object.entries(RESOURCE_CATEGORIES)) {
                if (catData.types.includes(shortType)) return catData.color;
            }
            return RESOURCE_CATEGORIES['Otros'].color;
        }
        window.getResourceColor = getResourceColor; // Exponer para configuraciones

        stacks.forEach((stackData, i) => {
            const col = i % stacksPerRow;
            const row = Math.floor(i / stacksPerRow);
            const x = startX + col * STACK_X_SPACING + Math.random() * 60 - 30;
            const y = startY + row * STACK_Y_SPACING + Math.random() * 60 - 30;
            
            // Usamos la constante global
            const headerH = STACK_HEADER_HEIGHT; 
            
            const width = 240;
            const height = 200;
            const headerColor = STACK_COLORS[i % STACK_COLORS.length];

            const stack = new joint.shapes.standard.HeaderedRectangle();
            stack.position(x, y);
            stack.resize(width, height);
            stack.attr({
                root: { title: stackData.data.id },
                header: { fill: headerColor, stroke: '#444', height: headerH },
                
                // CAMBIO AQUÍ: Fuente más grande (15px)
                headerText: { 
                    text: stackData.data.label, 
                    fill: '#fff', 
                    fontSize: 15, // Aumentado
                    fontWeight: 'bold', 
                    fontFamily: 'Segoe UI' 
                },
                
                body: { fill: '#252526', stroke: '#555', rx: 8, ry: 8 }
            });
            stack.set('type', 'stack');
            stack.set('stackName', stackData.data.id);
            stack.addTo(graph);
            stackElements.push(stack);

            const childResources = resources.filter(r => r.data.parent === stackData.data.id);
            const resWidth = 160, resHeight = 36;
            // Ajustamos el centro vertical (cy) para considerar el nuevo header
            const cx = x + width / 2 - resWidth / 2;
            const cy = y + headerH + (height - headerH - 20) / 2 - resHeight / 2;
            
            const spiralStep = 40;
            const spiralAngleStep = Math.PI / 7;

            childResources.forEach((res, idx) => {
                const resNode = new joint.shapes.standard.Rectangle();
                const angle = idx * spiralAngleStep;
                const radius = spiralStep * (1 + idx / (2 * Math.PI));
                resNode.position(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
                resNode.resize(resWidth, resHeight);
                const resourceColor = getResourceColor(res.data.type);
                
                function getBodyAttrs() {
                    if (window.__USER_CONFIG__ && window.__USER_CONFIG__.nodeColorMode === 'border') {
                        return { fill: '#222', stroke: resourceColor, strokeWidth: 3, rx: 5, ry: 5, cursor: 'pointer' };
                    } else {
                        return { fill: resourceColor, stroke: '#222', strokeWidth: 1, rx: 5, ry: 5, cursor: 'pointer' };
                    }
                }
                resNode.attr({
                    body: getBodyAttrs(),
                    label: { text: res.data.label, fill: '#fff', fontSize: 10, fontFamily: 'Segoe UI', cursor: 'pointer', textWrap: { width: 150, height: 30, ellipsis: true } }
                });
                resNode.set('data', res.data);
                stack.embed(resNode);
                resNode.addTo(graph);
                res._cell = resNode;
            });
            stack.fitEmbeds({ 
                padding: { 
                    top: STACK_HEADER_HEIGHT + 10, 
                    bottom: 20, 
                    left: 20, 
                    right: 20 
                } 
            });
            stack._cell = stack;
        });

        edges.forEach(edge => {
            let sourceNode = resources.find(r => r.data.id === edge.data.source)?._cell;
            let targetNode = resources.find(r => r.data.id === edge.data.target)?._cell;
            if (!sourceNode) sourceNode = stacks.find(s => s.data.id === edge.data.source)?._cell;
            if (!targetNode) targetNode = stacks.find(s => s.data.id === edge.data.target)?._cell;
            if (sourceNode && targetNode) {
                const link = new joint.shapes.standard.Link();
                link.source(sourceNode);
                link.target(targetNode);
                link.attr({ line: { stroke: '#666', strokeWidth: 1.5, targetMarker: { type: 'path', d: 'M 8 -4 0 0 8 4 z' } } });
                link.connector('rounded');
                link.addTo(graph);
            }
        });

        // Borde Visual del Área
        const areaBorder = new joint.shapes.standard.Rectangle();
        areaBorder.position(GRAPH_AREA.minX, GRAPH_AREA.minY);
        areaBorder.resize(GRAPH_AREA.maxX - GRAPH_AREA.minX, GRAPH_AREA.maxY - GRAPH_AREA.minY);
        areaBorder.attr({
            body: { fill: 'none', stroke: '#4fc3f7', strokeWidth: 3, pointerEvents: 'none' },
            label: { text: '', fill: 'none' }
        });
        areaBorder.addTo(graph);
        setTimeout(() => { areaBorder.toBack(); }, 100);


        // =================================================================
        // 4. INTERACCIONES, CÁMARA Y FÍSICAS (Sin cambios de lógica)
        // =================================================================

        let draggedElementId = null;
        let draggingSingleNodeStack = null;
        let dragStartPointer = null;
        let dragStartStackPos = null;

        paper.on('element:pointerdown', (ev, x, y) => {
            const model = ev.model;
            const parentStack = stackElements.find(stack => stack.getEmbeddedCells().length === 1 && stack.getEmbeddedCells()[0].id === model.id);
            if (parentStack && model !== parentStack) {
                draggingSingleNodeStack = parentStack;
                dragStartPointer = { x, y };
                const pos = parentStack.position();
                dragStartStackPos = { x: pos.x, y: pos.y };
                draggedElementId = null;
            } else {
                draggedElementId = model.id;
                draggingSingleNodeStack = null;
            }
        });

        paper.on('element:pointermove', (ev, x, y) => {
            if (draggingSingleNodeStack && dragStartPointer && dragStartStackPos) {
                const dx = x - dragStartPointer.x;
                const dy = y - dragStartPointer.y;
                let newX = dragStartStackPos.x + dx;
                let newY = dragStartStackPos.y + dy;
                const bbox = draggingSingleNodeStack.getBBox();
                const clamped = clampPosition(newX, newY, bbox.width, bbox.height);
                draggingSingleNodeStack.position(clamped.x, clamped.y);
                draggingSingleNodeStack.fitEmbeds({ 
                            padding: { 
                                top: STACK_HEADER_HEIGHT + 10, 
                                bottom: 20, left: 20, right: 20 
                            } 
                        });
            } else if (draggedElementId) {
                const model = ev.model;
                const bbox = model.getBBox();
                const clamped = clampPosition(bbox.x, bbox.y, bbox.width, bbox.height);
                model.position(clamped.x, clamped.y);
            }
        });

        paper.on('element:pointerup', () => {
            draggedElementId = null;
            draggingSingleNodeStack = null;
            dragStartPointer = null;
            dragStartStackPos = null;
        });

        // Constantes de tamaño mínimo (Cabecera + un poquito de cuerpo)
        const MIN_STACK_WIDTH = 240;
        const MIN_STACK_HEIGHT = 60; // Altura justa para el Header y poco más

        // REEMPLAZAR LA FUNCIÓN updateStackLayout ENTERA POR ESTA:
        function updateStackLayout(stack) {
            if (!stack || stack.get('hidden')) return;

            // 1. Filtrar solo visibles
            const visibleEmbeds = stack.getEmbeddedCells().filter(c => !c.get('hidden'));

            // CASO A: Stack vacío (o todo oculto) -> Tamaño mínimo
            if (visibleEmbeds.length === 0) {
                const currentSize = stack.size();
                // Solo redimensionar si es necesario para evitar parpadeo
                if (currentSize.width !== 240 || currentSize.height !== 60) {
                    stack.resize(240, 60);
                }
                return;
            }

            // CASO B: Hay contenido visible -> Ajuste manual ("Manual fitEmbeds")
            
            // 1. Calcular BBox de los hijos visibles
            const bbox = graph.getCellsBBox(visibleEmbeds);
            
            // Padding deseado
            const padding = { top: STACK_HEADER_HEIGHT + 20, bottom: 20, left: 20, right: 20 };
            
            // Calcular nueva geometría del Stack
            const newX = bbox.x - padding.left;
            const newY = bbox.y - padding.top;
            const newW = bbox.width + padding.left + padding.right;
            const newH = bbox.height + padding.top + padding.bottom;
            
            // 2. Aplicar Tamaño
            stack.resize(newW, newH);
            
            // 3. Aplicar Posición (Con truco de compensación)
            const currentPos = stack.position();
            const dx = newX - currentPos.x;
            const dy = newY - currentPos.y;
            
            // Si la diferencia es muy pequeña, ignoramos para ahorrar CPU
            if (Math.abs(dx) < 1 && Math.abs(dy) < 1) return;

            // Movemos el Stack (esto arrastra a TODOS los hijos, visibles y ocultos)
            stack.translate(dx, dy);
            
            // IMPORTANTE: Movemos los hijos VISIBLES hacia atrás (-dx, -dy)
            // Resultado: Los nodos visibles se quedan quietos en pantalla, 
            // y el Stack parece haberse movido debajo de ellos para abrazarlos.
            visibleEmbeds.forEach(child => {
                child.translate(-dx, -dy);
            });

            // NOTA: Los nodos OCULTOS se habrán movido con el stack (dx, dy).
            // Esto es positivo: cuando los vuelvas a mostrar, estarán más cerca 
            // del grupo actual en lugar de quedarse rezagados.
        }

        // --- SISTEMA DE FÍSICAS (CÓDIGO EXACTO PROVISTO) ---
        function physicsLoop() {
            resolveInternalPhysics();
            resolveStackCollisions();
            requestAnimationFrame(physicsLoop);
        }

        function resolveInternalPhysics() {
            let anyMoved = false;
            // AJUSTES DE FÍSICA ORIGINALES
            const REPULSION_DIST = 450;
            const REPULSION_STR = 300.0;
            const ATTRACTION_DIST = 130;
            const ATTRACTION_STR = 0.09;
            const CENTER_PULL = 0.035;
            const COLLISION_PADDING = 30;
            const DAMPING = 0.5;
            const STOP_THRESHOLD = 0.6;
            const MAX_SPEED = 15;

            stackElements.forEach(stack => {
                if (stack.get('hidden')) return;
                
                // FILTRO CRÍTICO: Solo nodos visibles para calcular el centro de masas
                const allChildren = stack.getEmbeddedCells();
                const visibleChildren = allChildren.filter(c => !c.get('hidden'));
                
                if (visibleChildren.length === 0) {
                    // Si no hay nodos visibles, actualizamos el layout (encoger stack) y salimos
                    updateStackLayout(stack);
                    return;
                }

                let cx = 0, cy = 0;
                visibleChildren.forEach(c => { const pt = c.getBBox().center(); cx += pt.x; cy += pt.y; });
                cx /= visibleChildren.length; cy /= visibleChildren.length;

                let stackMoved = false;

                // Bucle PRINCIPAL: Solo iteramos sobre nodos VISIBLES
                for (let i = 0; i < visibleChildren.length; i++) {
                    const nodeA = visibleChildren[i];
                    // (El chequeo nodeA.hidden ya no hace falta porque iteramos visibleChildren)
                    if (nodeA.id === draggedElementId) continue;
                    let fx = 0, fy = 0;
                    const aCenter = nodeA.getBBox().center();

                    // 1. REPULSIÓN (Solo contra otros visibles)
                    for (let j = 0; j < visibleChildren.length; j++) {
                        if (i === j) continue;
                        const nodeB = visibleChildren[j];
                        
                        // CRÍTICO: Si nodeB estuviera oculto, no entraría aquí, así que arreglado.
                        
                        const bCenter = nodeB.getBBox().center();
                        let dx = aCenter.x - bCenter.x;
                        let dy = aCenter.y - bCenter.y;
                        let distSq = dx * dx + dy * dy;
                        let dist = Math.sqrt(distSq) || 0.1;

                        if (dist < REPULSION_DIST) {
                            const factor = (1 - dist / REPULSION_DIST);
                            let force = factor * factor * REPULSION_STR;
                            fx += (dx / dist) * force;
                            fy += (dy / dist) * force;
                        }
                    }

                    // 2. ATRACCIÓN POR ENLACES (Solo si el otro extremo es visible)
                    const connectedLinks = graph.getConnectedLinks(nodeA);
                    connectedLinks.forEach(link => {
                        // Si el link está oculto, ignorar fuerzas
                        if (link.attr('./display') === 'none') return;

                        const sourceId = link.source().id;
                        const targetId = link.target().id;
                        let otherNode = null;
                        if (sourceId === nodeA.id && targetId) otherNode = graph.getCell(targetId);
                        else if (targetId === nodeA.id && sourceId) otherNode = graph.getCell(sourceId);

                        // CRÍTICO: Verificar que el otro nodo sea visible y esté en este stack
                        if (otherNode && visibleChildren.includes(otherNode) && !otherNode.get('hidden')) {
                            const otherCenter = otherNode.getBBox().center();
                            let dx = otherCenter.x - aCenter.x;
                            let dy = otherCenter.y - aCenter.y;
                            let dist = Math.sqrt(dx * dx + dy * dy) || 0.1;

                            if (dist > ATTRACTION_DIST) {
                                const force = (dist - ATTRACTION_DIST) * ATTRACTION_STR;
                                fx += (dx / dist) * force;
                                fy += (dy / dist) * force;
                            }
                        }
                    });

                    // 3. CENTER PULL
                    fx += (cx - aCenter.x) * CENTER_PULL;
                    fy += (cy - aCenter.y) * CENTER_PULL;

                    // Integración
                    fx *= DAMPING; fy *= DAMPING;
                    const speed = Math.sqrt(fx * fx + fy * fy);
                    if (speed > MAX_SPEED) { fx = (fx / speed) * MAX_SPEED; fy = (fy / speed) * MAX_SPEED; }
                    if (Math.abs(fx) < STOP_THRESHOLD) fx = 0;
                    if (Math.abs(fy) < STOP_THRESHOLD) fy = 0;

                    if (fx !== 0 || fy !== 0) {
                        nodeA.translate(fx, fy);
                        stackMoved = true;
                    }
                }

                // COLISIONES (Evitar solapamiento visual, solo entre visibles)
                const pad = COLLISION_PADDING;
                for (let i = 0; i < visibleChildren.length; i++) {
                    const childA = visibleChildren[i];
                    for (let j = i + 1; j < visibleChildren.length; j++) {
                        const childB = visibleChildren[j];
                        const bA = childA.getBBox();
                        const bB = childB.getBBox();
                        if (bA.x < bB.x + bB.width + pad && bA.x + bA.width + pad > bB.x &&
                            bA.y < bB.y + bB.height + pad && bA.y + bA.height + pad > bB.y) {
                            
                            // Lógica simple de separación
                            const cA = bA.center();
                            const cB = bB.center();
                            let dx = cA.x - cB.x; let dy = cA.y - cB.y;
                            if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) { dx = 1; dy = 0; }
                            const penX = (bA.width / 2 + bB.width / 2 + pad) - Math.abs(dx);
                            const penY = (bA.height / 2 + bB.height / 2 + pad) - Math.abs(dy);
                            let mx = 0, my = 0;
                            if (penX < penY) mx = penX * (dx > 0 ? 1 : -1); else my = penY * (dy > 0 ? 1 : -1);
                            
                            const aDrag = childA.id === draggedElementId;
                            const bDrag = childB.id === draggedElementId;
                            
                            if (aDrag) childB.translate(-mx, -my);
                            else if (bDrag) childA.translate(mx, my);
                            else { childA.translate(mx * 0.5, my * 0.5); childB.translate(-mx * 0.5, -my * 0.5); }
                            stackMoved = true;
                        }
                    }
                }

                // AL FINAL: Recalcular tamaño del Stack para ajustarse a los VISIBLES
                updateStackLayout(stack);

                if (stackMoved) anyMoved = true;
            });

            return anyMoved;
        }

        function resolveStackCollisions() {
            stackElements.forEach(stack => {
                if (stack.get('hidden')) return;
                const bbox = stack.getBBox();
                let newX = bbox.x; let newY = bbox.y;
                const borderPad = 10;
                newX = Math.max(GRAPH_AREA.minX + borderPad, Math.min(newX, GRAPH_AREA.maxX - borderPad - bbox.width));
                newY = Math.max(GRAPH_AREA.minY + borderPad, Math.min(newY, GRAPH_AREA.maxY - borderPad - bbox.height));
                if (newX !== bbox.x || newY !== bbox.y) stack.position(newX, newY);
                const newBox = stack.getBBox();
                stack.getEmbeddedCells().forEach(child => {
                    const childBox = child.getBBox();
                    let relX = childBox.x - newBox.x; let relY = childBox.y - newBox.y;
                    relX = Math.max(0, Math.min(relX, newBox.width - childBox.width));
                    relY = Math.max(0, Math.min(relY, newBox.height - childBox.height));
                    child.position(newBox.x + relX, newBox.y + relY);
                });
            });

            const padding = 15;
            for (let i = 0; i < stackElements.length; i++) {
                const A = stackElements[i];
                if (A.get('hidden')) continue;
                for (let j = i + 1; j < stackElements.length; j++) {
                    const B = stackElements[j];
                    if (B.get('hidden')) continue;
                    const bA = A.getBBox(); const bB = B.getBBox();
                    if (bA.x < bB.x + bB.width + padding && bA.x + bA.width + padding > bB.x &&
                        bA.y < bB.y + bB.height + padding && bA.y + bA.height + padding > bB.y) {
                        const cA = bA.center(); const cB = bB.center();
                        let dx = cA.x - cB.x; let dy = cA.y - cB.y;
                        if (dx === 0 && dy === 0) dx = 1;
                        const penX = (bA.width / 2 + bB.width / 2 + padding) - Math.abs(dx);
                        const penY = (bA.height / 2 + bB.height / 2 + padding) - Math.abs(dy);
                        let mx = 0, my = 0;
                        if (penX < penY) mx = penX * (dx > 0 ? 1 : -1); else my = penY * (dy > 0 ? 1 : -1);
                        
                        // ANTI-VIBRACIÓN STACKS
                        if (Math.abs(mx) < 3.0 && Math.abs(my) < 3.0) continue;

                        const aDrag = (A.id === draggedElementId || A.getEmbeddedCells().some(c => c.id === draggedElementId));
                        const bDrag = (B.id === draggedElementId || B.getEmbeddedCells().some(c => c.id === draggedElementId));
                        const f = 0.8;
                        function clampStackAndChildren(stack) {
                            const bbox = stack.getBBox();
                            const clamped = clampPosition(bbox.x, bbox.y, bbox.width, bbox.height);
                            stack.position(clamped.x, clamped.y);
                            stack.getEmbeddedCells().forEach(child => {
                                const childBox = child.getBBox();
                                let relX = childBox.x - bbox.x; let relY = childBox.y - bbox.y;
                                relX = Math.max(0, Math.min(relX, bbox.width - childBox.width));
                                relY = Math.max(0, Math.min(relY, bbox.height - childBox.height));
                                child.position(clamped.x + relX, clamped.y + relY);
                            });
                        }
                        if (aDrag) { B.translate(-mx * f, -my * f); clampStackAndChildren(B); }
                        else if (bDrag) { A.translate(mx * f, my * f); clampStackAndChildren(A); }
                        else {
                            A.translate(mx * 0.5 * f, my * 0.5 * f);
                            B.translate(-mx * 0.5 * f, -my * 0.5 * f);
                            clampStackAndChildren(A); clampStackAndChildren(B);
                        }
                    }
                }
            }
        }
        
        // Iniciar Físicas
        physicsLoop();


        // --- CÁMARA & ZOOM ---
        const zoomSpeed = 0.1;
        paper.el.addEventListener('wheel', function (e) {
            if (e.ctrlKey) return;
            e.preventDefault();
            const rect = paper.el.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const delta = e.deltaY < 0 ? 1 : -1;
            const oldScale = paper.scale().sx;
            const newScale = oldScale + (delta * zoomSpeed);
            if (newScale < 0.1 || newScale > 4) return;
            const tr = paper.translate();
            const logicalX = (x - tr.tx) / oldScale;
            const logicalY = (y - tr.ty) / oldScale;
            paper.scale(newScale, newScale);
            const newScreenX = logicalX * newScale + tr.tx;
            const newScreenY = logicalY * newScale + tr.ty;
            const dx = x - newScreenX; const dy = y - newScreenY;
            paper.translate(tr.tx + dx, tr.ty + dy);
        }, { passive: false });

        let panning = false, panStart = { x: 0, y: 0 };
        paper.on('blank:pointerdown', (e) => { panning = true; panStart = { x: e.clientX, y: e.clientY }; $('#paper').addClass('panning'); });
        $(document).on('mousemove', (e) => {
            if (!panning) return;
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            panStart = { x: e.clientX, y: e.clientY };
            const tr = paper.translate();
            paper.translate(tr.tx + dx, tr.ty + dy);
        });
        $(document).on('mouseup', () => { panning = false; $('#paper').removeClass('panning'); });


        // =================================================================
        // 5. BOTONES DE ACCIÓN (Centrar y Exportar)
        // =================================================================
        
        // --- Centrar Vista ---
        $('#center-view-btn').on('click', function () {
            const targetScale = 0.4;
            paper.scale(targetScale, targetScale);
            const areaCenterX = (GRAPH_AREA.minX + GRAPH_AREA.maxX) / 2;
            const areaCenterY = (GRAPH_AREA.minY + GRAPH_AREA.maxY) / 2;
            const paperRect = paper.el.getBoundingClientRect();
            const centerX = paperRect.width / 2;
            const centerY = paperRect.height / 2;
            paper.translate(centerX - areaCenterX * targetScale, centerY - areaCenterY * targetScale);
        });
        // Auto-centrar al inicio
        setTimeout(() => { $('#center-view-btn').trigger('click'); }, 100);

        // --- Exportar SVG ---
        // --- Exportar SVG (Corregido: Error cell.size) ---
        // --- Exportar SVG (Con Transparencia Condicional) ---
        $('#download-svg-btn').on('click', function () {
            try {
                // 1. FREEZE
                const currentTranslate = paper.translate();
                const currentScale = paper.scale();
                paper.scale(1, 1);
                paper.translate(0, 0);

                // 2. CLONE
                const svgExport = paper.svg.cloneNode(true);

                // 3. RESTORE
                paper.scale(currentScale.sx, currentScale.sy);
                paper.translate(currentTranslate.tx, currentTranslate.ty);

                // =========================================================
                // 4. APLICAR TRANSPARENCIAS
                // =========================================================
                const isBorderMode = window.__USER_CONFIG__ && window.__USER_CONFIG__.nodeColorMode === 'border';

                graph.getElements().forEach(element => {
                    const elGroup = svgExport.querySelector(`[model-id="${element.id}"]`);
                    if (!elGroup) return;

                    const body = elGroup.querySelector('[joint-selector="body"]') || 
                                 elGroup.querySelector('rect') || 
                                 elGroup.querySelector('path');
                    
                    if (body) {
                        const type = element.get('type');

                        // Stacks siempre transparentes
                        if (type === 'stack' || element.get('stackName')) {
                            body.setAttribute('fill', 'none');
                        }
                        // Nodos transparentes solo si estamos en modo borde
                        else if (isBorderMode) {
                            body.setAttribute('fill', 'none');
                        }
                    }
                });

                // 5. SMART CROP
                const visibleCells = graph.getCells().filter(cell => {
                    if (cell.get('hidden')) return false;
                    if (cell.isLink()) {
                        const s = cell.source().id; const t = cell.target().id;
                        if (!s || !t) return true;
                        const sC = graph.getCell(s); const tC = graph.getCell(t);
                        if (!sC || sC.get('hidden') || !tC || tC.get('hidden')) return false;
                        return true;
                    }
                    const size = cell.size();
                    if (size.width > 9000 || size.height > 5000) return false;
                    return true;
                });

                let contentBBox = graph.getCellsBBox(visibleCells);
                if (!contentBBox) contentBBox = { x: 0, y: 0, width: 100, height: 100 };

                const padding = 50;
                const minX = contentBBox.x - padding;
                const minY = contentBBox.y - padding;
                const vbW = contentBBox.width + (padding * 2);
                const vbH = contentBBox.height + (padding * 2);

                // 6. ATRIBUTOS
                svgExport.removeAttribute('style');
                svgExport.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                svgExport.setAttribute('viewBox', `${minX} ${minY} ${vbW} ${vbH}`);
                svgExport.setAttribute('width', vbW + 'px');
                svgExport.setAttribute('height', vbH + 'px');

                // 7. ESTILOS
                const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                style.textContent = `
                    text { 
                        font-family: "Segoe UI", sans-serif;
                        
                        /* 1. Texto oscuro (casi negro) para que se lea en papel/fondo blanco */
                        fill: #111111;
                        font-weight: 600; /* Un poco de negrita ayuda */

                        /* 2. El TRUCO DEL HALO: Borde blanco grueso */
                        stroke: #ffffff;
                        stroke-width: 3px;
                        stroke-linejoin: round; /* Bordes redondeados para que no haya picos */
                        
                        /* 3. MÁGIA: Dibuja el borde DETRÁS del relleno del texto */
                        /* Si no pones esto, el borde tapará la letra fina */
                        paint-order: stroke fill;
                        
                        /* Renderizado nítido */
                        text-rendering: geometricPrecision; 
                        -webkit-font-smoothing: antialiased;
                    }

                    /* Mantenemos el color oscuro para las líneas/bordes de los nodos */
                    .joint-element { 
                        fill: #252526; 
                    }
                    
                    /* Ocultar elementos display:none */
                    [display="none"] { visibility: hidden; } 
                `;
                svgExport.insertBefore(style, svgExport.firstChild);

                // 8. ENVIAR
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svgExport);

                vscode.postMessage({
                    type: 'downloadSVG',
                    data: 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)))
                });

            } catch (error) { console.error("Error exportando SVG:", error); }
        });


        // --- Exportar PNG ---
        // --- Exportar PNG (Con Stacks Transparentes) ---
        // --- Exportar PNG (Con Transparencia Condicional) ---
        // --- Exportar PNG (Con Transparencia Condicional) ---
        $('#download-png-btn').on('click', function () {
            try {
                // 1. FREEZE
                const currentTranslate = paper.translate();
                const currentScale = paper.scale();
                paper.scale(1, 1);
                paper.translate(0, 0);

                // 2. CLONE
                const svgExport = paper.svg.cloneNode(true);

                // 3. RESTORE
                paper.scale(currentScale.sx, currentScale.sy);
                paper.translate(currentTranslate.tx, currentTranslate.ty);

                // =========================================================
                // 4. APLICAR TRANSPARENCIAS (Stacks y Nodos)
                // =========================================================
                
                // Verificamos si el usuario tiene activado el modo "Solo Borde"
                const isBorderMode = window.__USER_CONFIG__ && window.__USER_CONFIG__.nodeColorMode === 'border';

                graph.getElements().forEach(element => {
                    // Buscamos el elemento correspondiente en el SVG clonado
                    const elGroup = svgExport.querySelector(`[model-id="${element.id}"]`);
                    if (!elGroup) return;

                    // Buscamos el cuerpo (rectángulo principal)
                    // JointJS suele usar joint-selector="body", si no, buscamos el primer rect/path
                    const body = elGroup.querySelector('[joint-selector="body"]') || 
                                 elGroup.querySelector('rect') || 
                                 elGroup.querySelector('path');
                    
                    if (body) {
                        const type = element.get('type');

                        // CASO A: Es un STACK -> Siempre transparente
                        if (type === 'stack' || element.get('stackName')) {
                            body.setAttribute('fill', 'none');
                        }
                        
                        // CASO B: Es un NODO (Recurso) y estamos en modo Borde
                        // Si isBorderMode es true, el nodo es negro (#222). Lo volvemos transparente.
                        else if (isBorderMode) {
                            body.setAttribute('fill', 'none');
                        }
                    }
                });

                // 5. SMART CROP (Recorte)
                const visibleCells = graph.getCells().filter(cell => {
                    if (cell.get('hidden')) return false;
                    if (cell.isLink()) {
                        const s = cell.source().id; const t = cell.target().id;
                        if (!s || !t) return true;
                        const sC = graph.getCell(s); const tC = graph.getCell(t);
                        if (!sC || sC.get('hidden') || !tC || tC.get('hidden')) return false;
                        return true;
                    }
                    const size = cell.size();
                    if (size.width > 9000 || size.height > 5000) return false;
                    return true;
                });

                let contentBBox = graph.getCellsBBox(visibleCells);
                if (!contentBBox) contentBBox = { x: 0, y: 0, width: 100, height: 100 };

                const padding = 50;
                const minX = contentBBox.x - padding;
                const minY = contentBBox.y - padding;
                const vbW = contentBBox.width + (padding * 2);
                const vbH = contentBBox.height + (padding * 2);

                // 6. ESCALADO (Calidad)
                let exportScale = 4; 
                let finalWidth = vbW * exportScale;
                let finalHeight = vbH * exportScale;
                const MAX_PIXELS = 25000000; 
                if (finalWidth * finalHeight > MAX_PIXELS) {
                    exportScale = Math.sqrt(MAX_PIXELS / (vbW * vbH));
                    finalWidth = vbW * exportScale;
                    finalHeight = vbH * exportScale;
                }

                svgExport.removeAttribute('style');
                svgExport.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                svgExport.setAttribute('viewBox', `${minX} ${minY} ${vbW} ${vbH}`);
                svgExport.setAttribute('width', finalWidth);
                svgExport.setAttribute('height', finalHeight);

                // 7. ESTILOS INYECTADOS                
                const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                style.textContent = `
                    text { 
                        font-family: "Segoe UI", sans-serif;
                        
                        /* 1. Texto oscuro (casi negro) para que se lea en papel/fondo blanco */
                        fill: #111111;
                        font-weight: 600; /* Un poco de negrita ayuda */

                        /* 2. El TRUCO DEL HALO: Borde blanco grueso */
                        stroke: #ffffff;
                        stroke-width: 3px;
                        stroke-linejoin: round; /* Bordes redondeados para que no haya picos */
                        
                        /* 3. MÁGIA: Dibuja el borde DETRÁS del relleno del texto */
                        /* Si no pones esto, el borde tapará la letra fina */
                        paint-order: stroke fill;
                        
                        /* Renderizado nítido */
                        text-rendering: geometricPrecision; 
                        -webkit-font-smoothing: antialiased;
                    }

                    /* Mantenemos el color oscuro para las líneas/bordes de los nodos */
                    .joint-element { 
                        fill: #252526; 
                    }
                    
                    /* Ocultar elementos display:none */
                    [display="none"] { visibility: hidden; } 
                `;
                svgExport.insertBefore(style, svgExport.firstChild);

                // 8. RENDERIZADO
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svgExport);
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                const img = new Image();
                img.onload = function () {
                    const canvas = document.createElement('canvas');
                    canvas.width = finalWidth;
                    canvas.height = finalHeight;
                    const ctx = canvas.getContext('2d');

                    // --- IMPORTANTE: FONDO DEL PNG ---
                    // Si quieres que sea REALMENTE transparente, comenta las líneas fillStyle y fillRect.
                    // Si quieres un fondo solido oscuro detrás de los nodos transparentes, déjalas.
                    
                    // ctx.fillStyle = '#1e1e1e'; 
                    // ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';

                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const pngData = canvas.toDataURL('image/png');
                    URL.revokeObjectURL(url);
                    vscode.postMessage({ type: 'downloadPNG', data: pngData });
                };
                img.src = url;

            } catch (error) { console.error("Error exportando PNG:", error); }
        });


        // =================================================================
        // 6. MINIMAPA (Corregido: Click en stacks y navegación inmediata)
        // =================================================================
        
        window._minimapPreview = null;

        // 1. Lógica de Movimiento (Usamos mousedown para respuesta inmediata)
        function handleMinimapNavigation(e) {
            e.stopPropagation(); 
            e.preventDefault();
            
            // Obtener el rectángulo del contenedor #minimap
            // Usamos e.currentTarget para asegurarnos de referirnos al contenedor, no a hijos
            const rect = e.currentTarget.getBoundingClientRect();
            
            const mx = e.clientX - rect.left - 10; 
            const my = e.clientY - rect.top - 10;

            const areaW = GRAPH_AREA.maxX - GRAPH_AREA.minX;
            const areaH = GRAPH_AREA.maxY - GRAPH_AREA.minY;
            
            // Evitar división por cero
            if (areaW === 0 || areaH === 0) return;

            const scaleX = 200 / areaW;
            const scaleY = 120 / areaH;

            const targetScale = paper.scale().sx;
            const paperRect = paper.el.getBoundingClientRect();
            
            const logicalW = paperRect.width / targetScale;
            const logicalH = paperRect.height / targetScale;

            // Centrar vista en el punto presionado
            const targetLogicalX = (mx / scaleX) + GRAPH_AREA.minX - (logicalW / 2);
            const targetLogicalY = (my / scaleY) + GRAPH_AREA.minY - (logicalH / 2);

            paper.translate(-targetLogicalX * targetScale, -targetLogicalY * targetScale);
        }

        // Asignamos la lógica al mousedown (click inmediato)
        $('#minimap').on('mousedown', handleMinimapNavigation);

        // Preview al mover el ratón
        $('#minimap').on('mousemove', function(e) {
            e.stopPropagation(); 
            e.preventDefault();
            $(this).css('cursor', 'crosshair'); // Cursor más preciso
            const rect = this.getBoundingClientRect();
            window._minimapPreview = { 
                mx: e.clientX - rect.left - 10, 
                my: e.clientY - rect.top - 10 
            };
        });

        $('#minimap').on('mouseleave', function(e) {
            $(this).css('cursor', 'default');
            window._minimapPreview = null;
        });

        // Función de Renderizado (Con pointer-events: none)
        function renderMinimap() {
            const svg = document.getElementById('minimap-svg');
            if (!svg) return;
            
            // Limpiar todo excepto si quisiéramos mantener algo (aquí borramos todo)
            while (svg.firstChild) svg.removeChild(svg.firstChild);

            const areaW = GRAPH_AREA.maxX - GRAPH_AREA.minX;
            const areaH = GRAPH_AREA.maxY - GRAPH_AREA.minY;
            const scaleX = 200 / areaW;
            const scaleY = 120 / areaH;

            // --- A. BORDE ---
            const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            border.setAttribute('x', 10); border.setAttribute('y', 10);
            border.setAttribute('width', 200); border.setAttribute('height', 120);
            border.setAttribute('stroke', '#4fc3f7'); border.setAttribute('stroke-width', '2');
            border.setAttribute('fill', 'none');
            // CLAVE: Ignorar clicks en el borde
            border.setAttribute('pointer-events', 'none'); 
            svg.appendChild(border);

            // --- B. STACKS ---
            stackElements.forEach((stack, idx) => {
                if (stack.get('hidden')) return;
                const bbox = stack.getBBox();
                const x = 10 + (bbox.x - GRAPH_AREA.minX) * scaleX;
                const y = 10 + (bbox.y - GRAPH_AREA.minY) * scaleY;
                const w = bbox.width * scaleX;
                const h = bbox.height * scaleY;

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x); rect.setAttribute('y', y);
                rect.setAttribute('width', w); rect.setAttribute('height', h);
                const color = STACK_COLORS[idx % STACK_COLORS.length] || '#ccc';
                rect.setAttribute('fill', color);
                rect.setAttribute('fill-opacity', '0.7');
                
                // CLAVE: Ignorar clicks en los stacks para que pasen al fondo
                rect.setAttribute('pointer-events', 'none'); 
                
                svg.appendChild(rect);
            });

            // --- C. VIEWPORT (Caja azul) ---
            const paperRect = paper.el.getBoundingClientRect();
            const scale = paper.scale().sx;
            const tr = paper.translate();
            const logicalX = (-tr.tx) / scale;
            const logicalY = (-tr.ty) / scale;
            const logicalW = paperRect.width / scale;
            const logicalH = paperRect.height / scale;
            
            const minix = 10 + (logicalX - GRAPH_AREA.minX) * scaleX;
            const miniy = 10 + (logicalY - GRAPH_AREA.minY) * scaleY;
            const miniw = logicalW * scaleX;
            const minih = logicalH * scaleY;

            const viewRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            viewRect.setAttribute('x', minix); viewRect.setAttribute('y', miniy);
            viewRect.setAttribute('width', miniw); viewRect.setAttribute('height', minih);
            viewRect.setAttribute('fill', '#4fc3f7'); viewRect.setAttribute('fill-opacity', '0.15');
            viewRect.setAttribute('stroke', '#4fc3f7'); viewRect.setAttribute('stroke-width', '2');
            
            // CLAVE: Ignorar clicks en el viewport
            viewRect.setAttribute('pointer-events', 'none');
            
            svg.appendChild(viewRect);

            // --- D. PREVIEW (Caja blanca) ---
            if (window._minimapPreview) {
                const { mx, my } = window._minimapPreview;
                const previewLogicalX = mx / scaleX + GRAPH_AREA.minX - logicalW / 2;
                const previewLogicalY = my / scaleY + GRAPH_AREA.minY - logicalH / 2;
                const minix2 = 10 + (previewLogicalX - GRAPH_AREA.minX) * scaleX;
                const miniy2 = 10 + (previewLogicalY - GRAPH_AREA.minY) * scaleY;
                
                const previewRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                previewRect.setAttribute('x', minix2); previewRect.setAttribute('y', miniy2);
                previewRect.setAttribute('width', miniw); previewRect.setAttribute('height', minih);
                previewRect.setAttribute('fill', '#fff'); previewRect.setAttribute('fill-opacity', '0.10');
                previewRect.setAttribute('stroke', '#fff'); previewRect.setAttribute('stroke-width', '2');
                
                // CLAVE: Ignorar clicks en el preview
                previewRect.setAttribute('pointer-events', 'none');
                
                svg.appendChild(previewRect);
            }
        }

        function minimapLoop() {
            renderMinimap();
            requestAnimationFrame(minimapLoop);
        }
        
        // Iniciar Minimapa
        minimapLoop();

    }); // Fin del document.ready
</script>
</body>
</html>