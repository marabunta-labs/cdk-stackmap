<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- CSP Permisiva -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://fonts.googleapis.com https://fonts.gstatic.com;">

    <!-- Dependencias -->
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jointjs/3.7.7/joint.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.6.0/backbone-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jointjs/3.7.7/joint.min.js"></script>

    <title>Stack Manager - Estabilidad Total</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #1e1e1e; font-family: 'Segoe UI', sans-serif; }
        
        #paper { width: 100%; height: 100%; cursor: grab; background-color: #1e1e1e; }
        #paper.panning { cursor: grabbing; }

        /* UI Panel */
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(30, 30, 30, 0.95); 
            border: 1px solid #454545; color: #cccccc;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            width: 260px; 
            border-radius: 8px;
            display: flex; flex-direction: column;
            font-size: 13px; z-index: 100;
            backdrop-filter: blur(10px);
        }

        #ui-header {
            padding: 15px; background: rgba(255, 255, 255, 0.03);
            border-bottom: 1px solid #454545; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            font-weight: 600; user-select: none; color: #fff;
        }
        
        .arrow { font-size: 12px; transition: transform 0.3s ease; }
        #ui.collapsed .arrow { transform: rotate(-90deg); }
        #ui.collapsed #stack-list-container { display: none; }

        #stack-list { padding: 5px; max-height: 300px; overflow-y: auto; }

        .stack-row {
            display: flex; align-items: center; gap: 10px;
            padding: 8px 10px; border-radius: 6px;
            cursor: pointer; transition: background 0.2s;
        }
        .stack-row:hover { background: rgba(255, 255, 255, 0.05); }
        
        .color-dot { width: 12px; height: 12px; border-radius: 4px; }
        
        input[type="checkbox"] { accent-color: #007acc; cursor: pointer; }

        #status-bar { 
            padding: 10px 15px; font-size: 11px; color: #aaa; 
            border-top: 1px solid #333; display: flex; justify-content: space-between;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="ui-header">
            <span>Stacks: <span id="counter-text" style="color: #4fc3f7;">0/0</span></span>
            <span class="arrow">▼</span>
        </div>
        <div id="stack-list-container">
            <div id="stack-list"></div>
            <div id="status-bar">
                <span>Motor:</span> <span style="color:#00ffaa">Estable (Sin Rebote)</span>
            </div>
        </div>
    </div>

    <div id="paper"></div>

    <script>
        $(document).ready(function() {

            // --- 1. CONFIGURACIÓN ---
            const namespace = joint.shapes;
            const graph = new joint.dia.Graph({}, { cellNamespace: namespace });

            const paper = new joint.dia.Paper({
                el: document.getElementById('paper'),
                model: graph,
                width: '100%', height: '100%',
                gridSize: 10, drawGrid: { color: '#333', thickness: 1 },
                background: { color: '#1e1e1e' },
                cellViewNamespace: namespace,
                interactive: (cellView) => {
                    if (cellView.model.get('hidden')) return false;
                    return cellView.model.isElement();
                },
                async: true,
                sorting: joint.dia.Paper.sorting.APPROX
            });

            // --- 2. DATOS ---
            const STACK_DATA = [
                { id: 'Frontend', color: '#252526', header: '#3F8624', resources: ['CloudFront', 'S3 Web', 'Route53'] },
                { id: 'Backend', color: '#252526', header: '#FF9900', resources: ['API Gateway', 'Auth Lambda', 'Core Lambda'] },
                { id: 'Database', color: '#252526', header: '#3355DA', resources: ['DynamoDB', 'Stream', 'Cache'] },
                { id: 'Data', color: '#252526', header: '#D13212', resources: ['Kinesis', 'Firehose', 'S3 Lake'] },
                { id: 'Ops', color: '#252526', header: '#8A2BE2', resources: ['CloudWatch', 'Alarms'] }
            ];

            const stackElements = []; 

            // --- 3. UI LOGIC ---
            function updateCounter() {
                const total = STACK_DATA.length;
                const visible = $('.stack-checkbox:checked').length;
                $('#counter-text').text(`${visible}/${total}`);
            }

            const listEl = $('#stack-list');
            STACK_DATA.forEach(data => {
                const row = $(`
                    <div class="stack-row">
                        <input type="checkbox" class="stack-checkbox" data-id="${data.id}" checked>
                        <div class="color-dot" style="background:${data.header}"></div>
                        <span>${data.id}</span>
                    </div>
                `);
                
                row.on('click', function(e) {
                    if (e.target.type !== 'checkbox') {
                        const cb = $(this).find('input');
                        cb.prop('checked', !cb.prop('checked')).trigger('change');
                    }
                });
                listEl.append(row);
            });
            updateCounter();

            $('#ui-header').on('click', () => $('#ui').toggleClass('collapsed'));

            $('.stack-checkbox').on('change', function() {
                const stackId = $(this).data('id');
                const isVisible = $(this).is(':checked');
                const stack = stackElements.find(el => el.get('stackName') === stackId);
                
                if (stack) {
                    const display = isVisible ? 'block' : 'none';
                    
                    // 1. Actualizar Stack y Hijos
                    stack.set('hidden', !isVisible);
                    stack.attr('./display', display);
                    
                    stack.getEmbeddedCells().forEach(child => {
                        child.set('hidden', !isVisible);
                        child.attr('./display', display);
                    });

                    // 2. Actualizar Enlaces con Lógica de Doble Verificación
                    // Solo mostramos el enlace si AMBOS extremos son visibles
                    const links = graph.getConnectedLinks(stack, { deep: true });
                    
                    links.forEach(link => {
                        if (!isVisible) {
                            // Si ocultamos el stack, la flecha desaparece siempre
                            link.attr('./display', 'none');
                        } else {
                            // Si estamos mostrando el stack, verificamos el vecino
                            const source = graph.getCell(link.source().id);
                            const target = graph.getCell(link.target().id);
                            
                            // ¿Están visibles origen y destino?
                            // (!get('hidden') asume que undefined es visible, lo cual es correcto al inicio)
                            const sourceVisible = source && !source.get('hidden');
                            const targetVisible = target && !target.get('hidden');

                            if (sourceVisible && targetVisible) {
                                link.attr('./display', 'block');
                            } else {
                                // Si el vecino sigue oculto, mantenemos la flecha oculta
                                link.attr('./display', 'none');
                            }
                        }
                    });
                }
                updateCounter();
            });

            // --- 4. CONSTRUCCIÓN ---
            const startX = 200;
            let startY = 200;

            STACK_DATA.forEach((data, i) => {
                const x = startX + (i % 3) * 350;
                const y = startY + Math.floor(i / 3) * 400;
                const headerH = 35;
                const width = 240;
                const height = 200;

                const stack = new joint.shapes.standard.HeaderedRectangle();
                stack.position(x, y);
                stack.resize(width, height);
                stack.attr({
                    root: { title: data.id },
                    header: { fill: data.header, stroke: '#444', height: headerH },
                    headerText: { text: data.id, fill: '#fff', fontSize: 13, fontWeight: 'bold', fontFamily: 'Segoe UI' },
                    body: { fill: data.color, stroke: '#555', rx: 8, ry: 8 }
                });
                stack.set('type', 'stack');
                stack.set('stackName', data.id);
                stack.addTo(graph);
                stackElements.push(stack);

                data.resources.forEach((resName, idx) => {
                    const res = new joint.shapes.standard.Rectangle();
                    res.position(x + 20 + Math.random()*50, y + 60 + Math.random()*50);
                    res.resize(120, 35);
                    res.attr({
                        body: { fill: '#333', stroke: data.header, strokeWidth: 1, rx: 5, ry: 5, cursor: 'pointer' },
                        label: { text: resName, fill: '#ddd', fontSize: 11, fontFamily: 'Segoe UI', cursor: 'pointer', textWrap: { width: 110, ellipsis: true } }
                    });
                    stack.embed(res);
                    res.addTo(graph);
                });
                stack.fitEmbeds({ padding: 25 });
            });

            function linkNodes(labelA, labelB) {
                const cells = graph.getCells();
                const nodeA = cells.find(c => c.attr('label/text') === labelA);
                const nodeB = cells.find(c => c.attr('label/text') === labelB);
                if (nodeA && nodeB) {
                    const link = new joint.shapes.standard.Link();
                    link.source(nodeA);
                    link.target(nodeB);
                    link.attr({
                        line: { stroke: '#666', strokeWidth: 1.5, targetMarker: { type: 'path', d: 'M 8 -4 0 0 8 4 z' } }
                    });
                    link.connector('rounded');
                    link.addTo(graph);
                }
            }
            linkNodes('CloudFront', 'API Gateway');
            linkNodes('Core Lambda', 'DynamoDB');
            linkNodes('Stream', 'Kinesis');

            // --- 5. FÍSICA SIN VIBRACIÓN ---
            
            let draggedElementId = null;
            paper.on('element:pointerdown', (ev) => draggedElementId = ev.model.id);
            paper.on('element:pointerup', () => draggedElementId = null);

            function physicsLoop() {
                // Solo un paso por frame para evitar sobre-corrección
                resolveInternalPhysics();
                resolveStackCollisions();
                requestAnimationFrame(physicsLoop);
            }

            function resolveInternalPhysics() {
                stackElements.forEach(stack => {
                    if (stack.get('hidden')) return;

                    const children = stack.getEmbeddedCells();
                    if (children.length === 0) return;

                    // Calcular centro de masa
                    let cx = 0, cy = 0;
                    children.forEach(c => { const pt = c.getBBox().center(); cx += pt.x; cy += pt.y; });
                    cx /= children.length; cy /= children.length;

                    let stackMoved = false;

                    // PASO 1: FUERZAS AMBIENTALES (Cohesión y Enlaces)
                    children.forEach(child => {
                        if (child.id === draggedElementId) { stackMoved = true; return; }

                        const center = child.getBBox().center();
                        let dx = 0, dy = 0;

                        // Cohesión (Volver al centro suavemente)
                        const distToCenter = Math.sqrt(Math.pow(cx - center.x, 2) + Math.pow(cy - center.y, 2));
                        if (distToCenter > 10) { 
                            const pullStrength = 0.02; 
                            dx += (cx - center.x) * pullStrength;
                            dy += (cy - center.y) * pullStrength;
                        }

                        // Enlaces (Tensión mínima)
                        const connectedLinks = graph.getConnectedLinks(child);
                        connectedLinks.forEach(link => {
                            const sourceId = link.source().id;
                            const targetId = link.target().id;
                            let otherNode = null;
                            if (sourceId === child.id && targetId) otherNode = graph.getCell(targetId);
                            else if (targetId === child.id && sourceId) otherNode = graph.getCell(sourceId);

                            if (otherNode) {
                                const otherParent = otherNode.getParentCell();
                                if (otherParent && otherParent.id !== stack.id) {
                                    const otherCenter = otherNode.getBBox().center();
                                    // REDUCIDO: Fuerza casi nula para que no arrastre el stack
                                    dx += (otherCenter.x - center.x) * 0.0001;
                                    dy += (otherCenter.y - center.y) * 0.0001;
                                }
                            }
                        });

                        // 4. FRICCIÓN Y UMBRAL
                        dx *= 0.8;

                        if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                            child.translate(dx, dy);
                            stackMoved = true;
                        }
                    });

                    // PASO 2: COLISIONES RÍGIDAS INTERNAS (Evitar solapamiento vertical/horizontal)
                    const padding = 10; // Espacio mínimo entre nodos

                    for (let i = 0; i < children.length; i++) {
                        const childA = children[i];
                        for (let j = i + 1; j < children.length; j++) {
                            const childB = children[j];

                            const bA = childA.getBBox();
                            const bB = childB.getBBox();

                            // Chequeo AABB con padding
                            if (bA.x < bB.x + bB.width + padding && bA.x + bA.width + padding > bB.x &&
                                bA.y < bB.y + bB.height + padding && bA.y + bA.height + padding > bB.y) {
                                
                                const cA = bA.center();
                                const cB = bB.center();
                                let dx = cA.x - cB.x;
                                let dy = cA.y - cB.y;
                                if (dx === 0 && dy === 0) dy = 1; // Desempate vertical por defecto

                                const penX = (bA.width/2 + bB.width/2 + padding) - Math.abs(dx);
                                const penY = (bA.height/2 + bB.height/2 + padding) - Math.abs(dy);

                                let mx = 0, my = 0;
                                // Resolver en el eje de menor penetración
                                if (penX < penY) mx = penX * (dx > 0 ? 1 : -1);
                                else my = penY * (dy > 0 ? 1 : -1);

                                // Gestión de arrastre: El nodo arrastrado es inamovible
                                const aDrag = childA.id === draggedElementId;
                                const bDrag = childB.id === draggedElementId;

                                const f = 1.0; // Respuesta rígida inmediata (sin rebote suave)

                                if (aDrag) {
                                    childB.translate(-mx * f, -my * f);
                                } else if (bDrag) {
                                    childA.translate(mx * f, my * f);
                                } else {
                                    childA.translate(mx * 0.5 * f, my * 0.5 * f);
                                    childB.translate(-mx * 0.5 * f, -my * 0.5 * f);
                                }
                                stackMoved = true;
                            }
                        }
                    }

                    if (stackMoved) {
                        stack.fitEmbeds({ padding: 25 });
                    }
                });
            }

            function resolveStackCollisions() {
                const padding = 15; // Padding generoso para evitar contacto visual

                for (let i = 0; i < stackElements.length; i++) {
                    const A = stackElements[i];
                    if (A.get('hidden')) continue;

                    for (let j = i + 1; j < stackElements.length; j++) {
                        const B = stackElements[j];
                        if (B.get('hidden')) continue;

                        const bA = A.getBBox();
                        const bB = B.getBBox();

                        if (bA.x < bB.x + bB.width + padding && bA.x + bA.width + padding > bB.x &&
                            bA.y < bB.y + bB.height + padding && bA.y + bA.height + padding > bB.y) {
                            
                            const cA = bA.center();
                            const cB = bB.center();
                            let dx = cA.x - cB.x;
                            let dy = cA.y - cB.y;
                            if (dx === 0 && dy === 0) dx = 1;

                            const penX = (bA.width/2 + bB.width/2 + padding) - Math.abs(dx);
                            const penY = (bA.height/2 + bB.height/2 + padding) - Math.abs(dy);

                            let mx = 0, my = 0;
                            if (penX < penY) mx = penX * (dx > 0 ? 1 : -1);
                            else my = penY * (dy > 0 ? 1 : -1);

                            // ANTI-VIBRACIÓN STACKS
                            // Umbral alto (3px). Si el choque es menor a 3px, lo ignoramos.
                            if (Math.abs(mx) < 3.0 && Math.abs(my) < 3.0) continue;

                            const aDrag = (A.id === draggedElementId || A.getEmbeddedCells().some(c => c.id === draggedElementId));
                            const bDrag = (B.id === draggedElementId || B.getEmbeddedCells().some(c => c.id === draggedElementId));

                            // Respuesta rápida para separar inmediatamente (0.8) en lugar de gradual
                            const f = 0.8; 

                            if (aDrag) B.translate(-mx * f, -my * f);
                            else if (bDrag) A.translate(mx * f, my * f);
                            else {
                                A.translate(mx * 0.5 * f, my * 0.5 * f);
                                B.translate(-mx * 0.5 * f, -my * 0.5 * f);
                            }
                        }
                    }
                }
            }

            requestAnimationFrame(physicsLoop);

            // --- 6. CÁMARA ---
            const zoomSpeed = 0.1;
            paper.on('blank:mousewheel element:mousewheel', (e, x, y, delta) => {
                e.preventDefault();
                const oldScale = paper.scale().sx;
                const newScale = oldScale + (delta * zoomSpeed);
                if (newScale < 0.2 || newScale > 4) return;
                const beta = oldScale / newScale;
                const ax = x - (x * beta);
                const ay = y - (y * beta);
                const tr = paper.translate();
                paper.translate(tr.tx - ax * newScale, tr.ty - ay * newScale);
                paper.scale(newScale, newScale);
            });

            let panning = false, panStart = {x:0, y:0};
            paper.on('blank:pointerdown', (e) => { panning=true; panStart={x:e.clientX, y:e.clientY}; $('#paper').addClass('panning'); });
            $(document).on('mousemove', (e) => {
                if(!panning) return;
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                panStart = {x:e.clientX, y:e.clientY};
                const tr = paper.translate();
                paper.translate(tr.tx + dx, tr.ty + dy);
            });
            $(document).on('mouseup', () => { panning=false; $('#paper').removeClass('panning'); });

        });
    </script>
</body>
</html>